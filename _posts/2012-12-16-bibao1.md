---
author: shmily
comments: true
date: 2012-12-16 13:22:31+00:00
layout: post
slug: bibao1
title: javascript的闭包理解(一)
wordpress_id: 349
categories:
- 一周一博
tags:
- javascript
---



**一、变量的作用域**

要理解闭包，首先必须理解Javascript特殊的变量作用域。

变量的作用域无非就是两种：全局变量和局部变量。

Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。










Js代码








	
  1. var n=999;

	
  2. 　　function f1(){

	
  3. 　　　　alert(n);

	
  4. 　　}

	
  5. 　　f1(); // 999





另一方面，在函数外部自然无法读取函数内的局部变量。

Js代码






	
  1. function f1(){

	
  2. 　　　　var n=999;

	
  3. 　　}

	
  4. 　　alert(n); // error









这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！








    Js代码








	
  1. function f1(){

	
  2. 　　　　n=999;

	
  3. 　　}

	
  4. 　　f1();

	
  5. 　　alert(n); // 999







**二、如何从外部读取局部变量？**

出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。

那就是在函数的内部，再定义一个函数。

Js代码



	
  1. function f1(){

	
  2. 　　　var n=999;

	
  3. 　　　function f2(){

	
  4. 　　　　　alert(n); // 999

	
  5. 　　　}

	
  6. 　}


在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！










Js代码








	
  1.  function f1(){

	
  2. 　　　　var n=999;

	
  3. 　　　　function f2(){

	
  4. 　　　　　　alert(n);

	
  5. 　　　　}

	
  6. 　　　　return f2;

	
  7. 　　}

	
  8. 　　var result=f1();

	
  9. 　　result(); // 999





**三、闭包的概念 **





 各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，**闭包就是能够读取其他函数内部变量的函数**。




由于在Javascript语言中，**只有函数内部的子函数才能读取局部变量**，因此可以把闭包简单理解成"定义在一个函数内部的函数"。










**四、闭包的用途**




 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的**可以读取函数内部的变量**，另一个就是**让这些变量的值始终保持在内存中**。




看下面这段代码：













Js代码




function a() {
var i = 0;
function b() {
alert(++i);
}
return b;
}
var c = a();
c();










在执行完var c=a()后，变量c实际上是指向了函数b，b中用到了变量i，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。










 简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但你一定能看懂。理解闭包需要循序渐进的过程。




在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。







  那么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。







:http://www.felixwoo.com/archives/247



